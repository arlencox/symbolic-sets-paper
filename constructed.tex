\section{Constructed Set Abstractions}
\label{sec:constructed}
An abstract domain is defined by a class of set constraints and their machine
representation, and abstract operations following the signature given in
Section~\ref{s:3:2:sign}.
In this section, we introduce three basic set abstract domains (respectively
based on linear constraints, QUIC graphs, and BDDs) and two set abstract
domain functors, that map a set domain into another, more expressive or
efficient one.

\subsection{Linear Set Constraints}
\label{s:4:1:lin}
\newcommand{\adomlin}{\adom_{\zcl}}
\newcommand{\gammalin}{\gamma_{\zcl}}
\paragraph{Abstract elements and their concretization.}
Our first set abstract domain relies on {\em linear} set equality
constraints, of the form \( \setvx = \{ y_0, \ldots, y_k \} \suplus
\setvz_0 \suplus \ldots \suplus \setvz_l \).
The advantage of this representation is to provide a rather straightforward
normalization of the representation of constraints.
Note they also include emptiness constraints.
Our implementation of abstract domain \( \adomlin \) describes four kinds
of constraints:
\begin{compactitem}
\item {\em linear} constraints of the form \( \setvx = \setvy_0 \suplus
  \ldots \suplus \setvy_k \suplus \setvz_0 \suplus \ldots \suplus
  \setvz_l \), where \( \setvy_0, \ldots, \setvy_k \) are singleton
  (in our implementation, each variable may appear at most {\em once}
  as the left hand side of such a constraint);
\item inclusion constraints of the form \( \setvy \subseteq \setvx \);
\item equality constraints of the form \( \setvy = \setvx \).
\end{compactitem}
Thus, an element of \( \adomlin \) is either \( \bot \) or a conjunction of
such constraints.
The associated concretization \( \gammalin: \adomlin \rightarrow
\partsof{\states} \) is of the same form as that of the symbolic sets
language of Definition~\ref{d:1:symsets} (thus, we do not formalize it
in full details).
The machine representation of our implementation utilizes persistent
dictionaries, which reduces basic queries for facts (such as: ``does
abstract state \( \astate \) entail that \( \setvx \subseteq \setvy
\suplus \setvz \)~?'') to dictionary searches.

\paragraph{Abstract operators.}
The core algorithm of \( \adomlin \) normalizes an abstract values by
expanding nested linear constraints:
for instance, \( \setvx_0 = \setvx_1 \suplus \setvx_2 \wedge \setvx_1
= \setvx_3 \suplus \setvx_4 \) is rewritten into  \( \setvx_0 = \setvx_2
\suplus \setvx_3 \suplus \setvx_4 \wedge \setvx_1 = \setvx_3 \suplus
\setvx_4 \).
This process terminates as constraints represented in \( \adomlin \)
do not contain cycles.
It is performed incrementally by all abstract operations.

Abstract operations \( \adomisbot, \adomassume, \adomprove \) are all
made very fast by this normalization.
Operation \( \adomforget \) simply drops all constraints that involve
a given set variable.
Finally, \( \adomjoin \) and \( \adomwiden \) need to {\em generalize}
constraints:
\begin{example}[]
  Let us assume that \( \astate_0 \) (\resp, \( \astate_1 \)) stands for
  the set of constraints \( \setvx_0 = \setvx_1 \suplus \setvx_2
  \wedge \setvx_3 = \emptyset \) (\resp, \( \setvx_0 = \setvx_1 \suplus
  \setvx_2 \suplus \setvx_3 \)).
  Then \( \adomjoin( \astate_0, \astate_1 ) \) returns the constraint
  \( \setvx_0 = \setvx_1 \suplus \setvx_2 \suplus \setvx_3 \).
\end{example}
\memcad~\cite{memcad:15:sas} relies on \( \adomlin \) to represent set
constraints since it mainly needs to express constraints over set
partitions.
In the other hand, \( \adomlin \) is not adapted to the precise
description of non disjoint unions.

\subsection{QUIC graphs}
\label{s:4:2:quic}

A QUIC graph is a directed hypergraph data structure used to represent relational set constraints.  Each edge in the hypergraph corresponds to a subset constrtaint and each hypergraph is a conjunction of subset constraints as described by the following logic $P$.  Each vertex of the graph can be an element of $S$: the empty set, a singleton set, or a set variable:
% - set of predicates
\begin{align*}
  P ::= P \logand P \ | \ S \cap \ldots \cap S \subseteq S \cup \ldots \cup S \qquad
  S ::= \emptyset \ | \ \{x\} \ | \ X
\end{align*}

% - concretization function
QUIC graphs concretizes in a similar fashion to constrain logic as defined in Figure~\ref{f:4:symsets}.  Each edge concretizes according to its logical meaning:
\begin{align*}
  \gamma(P_1 \logand P_2) &\defeq \{ \state \ | \ \state \in \gamma(P_1) \logand \state \in \gamma(P_2) \} \\
  \gamma(\ S_1 \cap \ldots \subseteq S'_1 \cup \ldots) &\defeq \Set{ \state | \begin{array}{@{}l@{}}
       (\state,c_1) \in \gamma(S_1) \logand \ldots \logand (\state,c'_1) \in \gamma(S'_1) \logand \ldots \\
       {} \logand c_1 \cap \ldots \subseteq c'_1 \cup \ldots
    \end{array}
  } \\
  \gamma(\emptyset) \defeq \{ (\state, \emptyset) \}
  \qquad \gamma(\{x\}) &\defeq \{ (\state, \state(x)) \ | \ |\state(x)| = 1 \} \qquad \gamma(X) \defeq \{ (\state, \state(X)) \}
\end{align*}

% - algorithms main ideas
QUIC graphs is designed for efficiently performing two operations: (1) $\adomforget$, which matches edges containing the symbol to be forgotten with each other to produce new edges without that symbol; and (2) content reasoning, which is not a design goal for symbolic sets.  The join operation is primarily based on saturation heuristics.  It keeps common conjunctions from both sides of the join.  To aid this process, it uses a form of saturation that produces new conjuncts based on pattern matches.  A sufficiently large set of patterns must be provided to attain precision, but additional patterns increases the cost of joins.
% - example
\begin{example}[QUIC graph join]  Consider the following join operation:
    \begin{align*}
      X_1 \subseteq X_3 \logand X_3 \subseteq X_2 \ \sqcup \ X_1 \subseteq X_4 \logand X_4 \subseteq X_2
    \end{align*}
    There is an obvious result: $X_1 \subseteq X_2$.  Whether or not QUIC graphs derives this result or top is determined by the pattern matches that are installed.  If the pattern $X_a \subseteq X_b \logand X_b \subseteq X_c \Rightarrow X_a \subseteq X_b$ is installed, it will first apply the pattern to both sides and then keep common conjuncts, getting the desired result.  Without that pattern, or a similar substitute, QUIC graphs derives $\top$.
\end{example}

\subsection{BDD-based Set Constraints}
\label{s:4:3:bdd}
% - BDD structure quickly explained
Binary decision diagrams (BDDs) are a canonical representation of Boolean algebraic functions.  There are three basic syntactic elements of a BDD.  The $\textsc{True}$ and $\textsc{False}$ elements represent the obvious constants, but $\textrm{ITE}(X,B_t,B_e)$ is an if-then-else structure.  If the variable $X$ is $\true$, the result of evaluating $B_t$ is returned, otherwise the result of evaluating $B_e$ is returned.
\begin{align*}
  B ::= \textsc{True} \ | \ \textsc{False} \ | \ \textrm{ITE}(X,B_t,B_e)
\end{align*}
What makes BDDs canonical is that we only consider reduced, ordered BDDs, where it is assumed that there is a total order $\prec$ on the variables.  An $\textrm{ITE}(X,B_t,B_e)$ can only be constructed if $X \prec X'$ for all variables $X'$ in $B_t$ or $B_e$.  Additionally, structural sharing is mandated, so the reuse of the same syntax is referentially identical to any other use of that syntax.

% - encoding of a class of set constraints (it gives the gamma)
% - algorithms main ideas
% - example

\subsection{The Equalities Domain Functor: Compact Equality Constraints}
\label{s:4:4:eqs}
% - origin of the equalities problem (cases where there are too many variables
%   and most of them are equal, consequences in terms of complexity)
% - principle of the functor
% - abstract states and concretization
% - example

\subsection{The Packing Domain Functor: Sparse Constraints}
\label{s:4:5:packs}
% - issue with relational abstract domains
% - packing principle (citations to Astree)
% - abstract states and concretization
% - example