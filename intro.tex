\section{Introduction}
\label{s:1:intro}

% Don't forget to add references!!!

It is well understood that the verification of program properties that
involve data structures is a challenging problem~\cite{jahob:thesis:07,compass:popl:11,fixbag:cav:11,celia:vmcai:12,ab:ecoop:13,hoo:14:sas,memcad:15:sas}.
There are a multitude of reasons for this, but one key reason is that
if a data structure is unbounded, there is a potentially unbounded number of constraints on its elements.  Since these constraints often affect important properties such as memory safety~\cite{memcad:15:sas}, functional correctness~\cite{fixbag:cav:11}, or basic program behavior~\cite{hoo:14:sas}, it is vital to develop techniques for efficiently reasoning about relationships between unbounded numbers of elements.

Here we use set constraints to reason about unbounded collections of elements.  Set constraints can be used to dynamically partition data structures, correlate collections of elements with one another, or determine analysis case splits.  They are useful for representing data and pointers relationships in structures such as maps, graphs, lists, sets, and arrays.  They can be combined with other techniques such as separation logic~\cite{hoo:14:sas,memcad:15:sas} and numerical analyses~\cite{quicr:cav:14} to enhance those analyses.

%% xr: need to adjust overview, there is some repetition now
For example, consider the program in Figure~\ref{fig:intro-example}
that copies one map on top of another.
Within the loop, there is a complex relationship between the sets of
keys of \ttvar{src} and \ttvar{dst}.
At the specified point, the keys of \ttvar{src} can be partitioned into
three parts.
The keys $X_v$ already visited by the loop, the element currently being
visited by the loop $\{\varx\}$, and the keys $X_n$ not visited by
the loop.
The keys of \ttvar{dst} can be partitioned into those originally in
\ttvar{dst} that have not been overwritten, and those $X_v$ that have
been overwritten or added from \ttvar{src}.
This set reasoning allows precise symbolic tracking of the provenance
of map partitions.

\begin{figure}[tb]
  \newbox\exprogbox
  \begin{lrbox}{\exprogbox}
    \begin{minipage}[t][1cm][b]{0.4\textwidth}
      \begin{lstlisting}[language=python]
def extend(dst, src):
  for x in src:
    # invariant point
    dst[x] = src[x]
      \end{lstlisting}
    \end{minipage}
  \end{lrbox}
  \newbox\exproginv
  \begin{lrbox}{\exproginv}
    \begin{minipage}[t][0.9cm][b]{0.4\textwidth}
      \begin{align*}
        \exists X_v, X_n. \; keys(\ttvar{src})
        & = X_v \suplus \{\varx\} \suplus X_n
        \\
        {} \logand keys(\ttvar{dst})
        & = (keys(\ttvar{dst})_0 \setminus X_v) \suplus X_v
      \end{align*}
    \end{minipage}
  \end{lrbox}
  \centering
  \subfigure[Function to copy all keys and values from map \ttvar{src}
  onto map \ttvar{dst}]{\usebox\exprogbox}
  \quad
  \subfigure[Set abstraction at \texttt{\textit{invariant point}}]{%
    \usebox\exproginv}
  \caption{Set constraints can relate portions of data structures}
  \label{fig:intro-example}
\end{figure}

This paper focuses on abstractions for states described by the logic for \emph{symbolic sets}.  The logic consists of a Boolean algebra over the set variables with singleton sets. We find that this subset is sufficiently large to be useful and we
believe that it serves as a good starting point for extensions to the
logic, such as reasoning about explicit set contents or more precise
cardinality.

However, despite the fact that we are not reasoning about the values contained in sets or complex cardinalities, Boolean algebras, by themselves, are challenging for invariant generation.  Naive approaches such as saturation and pattern matching rarely work without complex heuristics~\cite{fixbag:cav:11,ab:ecoop:13}.  It is unavoidable that the worst-case time for precise invariant generation will be exponential because of the Boolean algebra. However, it is desirable that invariant generation should be efficient in the common case, and unlike systems that involve complex heuristics, lose precision only in understandable and predictable ways.

% AC: seems like this could be tightened up and combined with the next paragraph
In this paper we aim to address the performance and precision challenges
by defining a variety of interchangeable abstractions and abstraction
combinators that can be selected for a particular application.
This includes abstractions based on binary decision diagrams,
satisfiability modulo theories, and linear set constraints.
Additionally, it includes performance and precision enhancing combinators for tracking
singleton sets, handling equality, and doing dynamic variable packing.
These abstractions and combinators exist within a general framework so
that additional abstractions and combinators can be easily added.
This framework is available within the QUICr library, which is now
used by two research analyzers.

In this paper we make the following contributions.
\begin{compactitem}
\item We define a common interface for symbolic set abstractions that is designed to meet the needs of static analyzers.
  %% xr: not very specific; I suggest to add "adapted for static analysis"
  %%     or "that describes static analyzers set reasoning needs"
  This interface is used as the framework for all set
  abstractions (Section~\ref{sec:logic-and-set-abstraction}).
\item Using specialized data structures to represent set constraints uniformly and efficiently, we construct scalable abstractions and combinators for set relationships.  These abstractions are easily swappable, customizable, and extensible depending on the application domain.  We designed these abstractions to target real-world problems in data structure verification (Section~\ref{sec:constructed}).
\item We show that off-the-shelf solvers can be adapted to the set abstraction interface.  We demonstrate this with an abstraction based on satisfiability modulo theories (Section~\ref{sec:solvers}).
\item We compare and contrast the constructed abstractions, solver
  abstractions, with and without various abstraction combinators on a
  variety of real-world benchmarks.  We find that due to the renaming and projection abstract domain operations that constructed abstractions perform better than highly-tuned off-the-shelf solvers while offering comparable precision (Section~\ref{sec:evaluation}).
\end{compactitem}